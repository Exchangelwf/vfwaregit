//add by jwd on 20160108#ifdef WIN32#pragma warning( disable : 4786)#endif#include<cstring>#include <stdlib.h>#include "networkservice/CNetWorkClient.h"#include "networkservice/NetCore.h"#include "networkservice/IVnPdu.h"#include "common/DVRDEF.H"#include "common/Types.h"#include "system/File.h" namespace NETWORKSERVICE{	static int NetSendClientDataUnlock(struct conn *c)	{		NetQueue_t *queue = NULL;    	    msghdr_t *p = NULL , *q;	    msghdr_t *msg;	    int max_send_buf = 128* 1024; //最大的发送缓冲,需要通过计算得出	    unsigned long n;	    int iDataFlag = 0;//!标识传送视频数据标识	    struct timeval time_now;#ifdef LINUX	    gettimeofday(&time_now, NULL);#else	    time_now.tv_sec = 0;	    time_now.tv_usec = SystemGetMSCount()*1000; #endif		queue = &c->DataTransferQueue[0];		if(0  == queue->totalSize)	    {	    __trip;	        return 0;	    }		unsigned  total_size =0;	    struct iovec iov[200];	    msg = queue->head;	    if (msg->buf_len > max_send_buf)	    {	        _printd("msg->buf_len = %d\r\n",msg->buf_len);	    }	    	    for(n = 0; 	        n < (sizeof(iov) / sizeof(iov[0])) 	        && (msg != NULL)                  	        /*&& ((total_size + msg->buf_len) <= max_send_buf)*/;	        n ++) 	    {	        iov[n].iov_base = msg->buf;	        iov[n].iov_len  = msg->buf_len;	        total_size     += msg->buf_len;	         	        msg = msg->next;	    }	    if(0 == n) 	    {	    __trip;	        c->iSocketSendFlag = 1;	        return 0;	    }		long nRet  = 0;		nRet = writev(c->sock, iov, n);		if(nRet < 0 ) 	    { 	        nRet = 0;	    }	    if(nRet < (long)total_size)	    {	        c->iSocketSendFlag = 1;	    }		queue->totalSize -= nRet ;   // 队列的总长度做相应的更改	    c->TransferQueue.totalSize -= nRet;/*这是总的数据长度，保持向前兼容*/		 for(msg = queue->head;msg && (nRet >=msg->buf_len); )	    {	        /*	         * 数据已经发送成功,如果设置了回调函数在这里处理	         */	        nRet -= msg->buf_len;	        q = msg;	        msg = msg->next;	        if(q->callback) 	        {	            q->callback(q->context);	        }	        if(q->msgAddr)	        {	            free_manager(c,q->msgAddr,(enum_malloc_method)q->malloc_flags);	        }	    }		if(nRet > 0) 	    {	        assert(msg != NULL);	        msg->buf      = (void *)((char *)msg->buf + nRet);	        msg->buf_len -= nRet;	        	        /*	         * 把优先级提到最高,不允许后面的数据插到它的前面,避免破坏数据包的完整性	         */	        for(p = msg, q = msg->next;	            q && p->msg_flags & MSG_FLAGS_MORE;) 	        {	            p = p->next;	            q = p == NULL ? NULL : p->next;	        }	    } 	    queue->head    = msg;	    if(msg)  	    {	        queue->startTime = msg->timestamp;	    }	    if(NULL == queue->head)	    {	        queue->totalSize = 0;	    }		return 0;  	}	static int NetClientQueueOverLimit(struct conn *c)	{	    NetQueue_t *queue = NULL;  	    queue = &c->DataTransferQueue[0];	    if(NULL ==queue)	    {	         return 0;    	    }	    if(queue->totalSize > 100*1024)	    {	        return 1;	    }	    else	    {	        return 0;	    }		}	 CClientUpgrate::CClientUpgrate(string uploaddir,string uploadfilename):m_ifilecurrent(0),m_ifiletotal(0),m_istatus(0),m_ifilecurrent_last(0)	 { 		m_file = NULL;		m_pConect = NULL;		WEB_UPDATE_TMPDIR=uploaddir;		WEB_UPDATE_FILENAME=uploadfilename;	 }	 CClientUpgrate::~CClientUpgrate()	 {		if(NULL != m_file)		{			delete m_file;		}	 }	 bool CClientUpgrate::Start(int iFilelen)	 {		char Filename[256];		char Cmd[256];				if(0 == iFilelen)		{			return FALSE;		}		memset(Filename, 0, sizeof(Filename));		snprintf(Filename, sizeof(Filename), "%s/%s",WEB_UPDATE_TMPDIR.c_str(),WEB_UPDATE_FILENAME.c_str());				if( 0 == access(Filename, 0))		{					memset(Cmd, 0, sizeof(Cmd));			snprintf(Cmd, sizeof(Cmd), "rm  %s/%s -rf",WEB_UPDATE_TMPDIR.c_str(),WEB_UPDATE_FILENAME.c_str());			cmdpopen(Cmd);		}				snprintf(Cmd, sizeof(Cmd),"mkdir %s -p", WEB_UPDATE_TMPDIR.c_str());//确保文件夹的存在		cmdpopen(Cmd);						m_file = new CFile();		if(NULL == m_file)		{			printf("CClientUpgrate::Start m_file is NULL,creat error\n");			return FALSE;		}		if(m_file->Open(Filename, CFile::modeCreate|CFile::modeReadWrite | CFile::modeNoTruncate))		{			m_ifiletotal = iFilelen;			m_istatus = 1;			m_file->Seek(0, CFile::begin);			m_ctimer.Start(this, (VD_TIMERPROC)&CClientUpgrate::TimerCheck, 60000, 60000);		}		else		{			printf("CClientUpgrate::Start m_file->Open error\n");			delete m_file;			m_file = NULL;			return FALSE;		}		return TRUE;	}	void CClientUpgrate::SetConnect(struct conn *c)	{		m_pConect = c;	}	int CClientUpgrate::UpgrateStatus()	{		return  m_istatus;	}	void CClientUpgrate::Stop()	{		char Cmd[256];		memset(Cmd, 0, sizeof(Cmd));		//snprintf(Cmd, sizeof(Cmd), "rm %s/%s -rf",WEB_UPDATE_TMPDIR.c_str(),WEB_UPDATE_FILENAME.c_str());		if(NULL != m_file)		{			m_file->Close();			cmdpopen(Cmd);			delete m_file;			m_file = NULL;		}		m_ifilecurrent = 0;		m_ifilecurrent_last = 0;		m_ifiletotal = 0;		m_istatus = 0;	}	void CClientUpgrate::AppendData(char * buf,int len)	{		if(NULL == buf || len == 0 || NULL == m_file)		{			_printd("data no invaile!!!");			return;		}		//m_ctimer.Stop();		m_file->Write(buf,len);		m_file->Flush();		m_ifilecurrent += len;			_printd("m_ifilecurrent = [%d],m_ifilecurrent_last[%d],m_ifiletotal[%d],len=%d", m_ifilecurrent,m_ifilecurrent_last,m_ifiletotal,len);		if(m_ifilecurrent == m_ifiletotal)		{			int iRet;			m_file->Close();			iRet = wja_FirmwareUpload(MAINCHIP);			Stop();			if(iRet)			{				SendUpgrateStatus(1);				sleep(5);				cmdpopen((char*)"reboot");			}			else			{				SendUpgrateStatus(0);					}			m_ctimer.Stop();		}		else		{			//m_ctimer.Start(this, (VD_TIMERPROC)&CClientUpgrate::TimerCheck, 60000, 60000);		}	}	int CClientUpgrate::TimerCheck(int arg)	{		if((m_istatus)&&(m_ifilecurrent_last)&&(m_ifilecurrent!=m_ifiletotal)&&(m_ifilecurrent_last==m_ifilecurrent) )//upload  check ,whether data receive		{			Stop();//1分钟无数据就升级失败			SendUpgrateStatus(0);			m_ctimer.Stop();		}		else		{			m_ifilecurrent_last=m_ifilecurrent;		}	}		bool CClientUpgrate::SendUpgrateStatus(int status)	{		if(NULL != m_pConect)		{			DVRIP szHead;			memset(&szHead, 0 , sizeof(DVRIP));			memcpy(szHead.head_token,"WJAPRIVA",8);			szHead.dvrip_cmd = UPDATA_NOW;			szHead.dvrip_r0  = status;			msghdr_t msghdr;			memset(&msghdr, 0, sizeof(msghdr));			msghdr.buf	   = (void*)&szHead;			msghdr.buf_len = sizeof(DVRIP);			DvrNetSendMsg(m_pConect, &msghdr);			}		else		{			return FALSE;		}		return TRUE;	}	//PATTERN_SINGLETON_IMPLEMENT(CNetWorkClient);	CNetWorkClient::CNetWorkClient():CThread("NetWorkClient", TP_NET), m_bIsNetRunning(false)	{		printf("CNetWorkClient::CNetWorkClient()>>>>>>>>>\n");		m_iOnline = 0;		m_bRegisterFlag = false;		m_iKeepStatus = 0;		g_TimerManager.Start();		memset(&m_remote, 0, sizeof(struct io));				NetClientIoInit();		m_ctimer.Start(this, (VD_TIMERPROC)&CNetWorkClient::TimerCheckBuf, 60000, 60000);		m_cKeepLive.Start(this, (VD_TIMERPROC)&CNetWorkClient::TimerKeepLive, 30000, 30000);	}	CNetWorkClient::~CNetWorkClient()	{		if(NULL != m_upgrate)		{			delete m_upgrate;		}		m_ctimer.Stop();	}	int  CNetWorkClient::NetClientIoInit()	{		struct conn  *c = &m_conect;		memset(c, 0, sizeof(*c));                  		MutexCreate(&c->hMutex, MUTEX_FAST);		c->sock        = INVALID_SOCKET;		int iTemp;		//c->watch    = io->process;		//c->fini     = io->fini;		//c->context  = io->context;		c->watch_data    = c;		c->birth    = 0;		c->iOnlineFlag = 1;		c->iUserBookAlarm = 0;		c->ulConnSequenceFlag  = 1;		c->iExtraCfgChangFlag = 1;		c->iSocketNeedChgFlag = 0;		c->iClientFlag = 0;		memset( &c->NodeFree,0,sizeof(Node_t));		c->iSubConnFlag = 0;		c->iRecDownNormalEndFlag = 0;		c->iUpPicMsk = 0;		c->bUpPicFlag =0;		c->bSend =0;	}	int  CNetWorkClient::NetClientFreeBuf()	{	    NetQueue_t *queue = &m_conect.TransferQueue;	    msghdr_t *msg, *q;	    int iChn = 0;	    printf("disconnecting %p\r\n", &m_conect);	    m_conect.flags |= FLAG_FINISHED; 	    if (m_conect.hMutex)	    {	        MutexEnter(m_conect.hMutex);	    }    	 for(iChn = 0; iChn < 2;iChn ++)	    {	       queue = &m_conect.DataTransferQueue[iChn];	        	        for(msg = queue->head;msg ; ) 	        {	            q = msg;	            msg = msg->next;	            if(q->callback) 	            {	                q->callback(q->context);	            }	            if(q->msgAddr)	            {	                free_manager(&m_conect,q->msgAddr,(enum_malloc_method)q->malloc_flags);	            }	        }    	    }				for(int iTemp = 0; iTemp< (2); iTemp ++)		{		    memset(&m_conect.DataTransferQueue[iTemp] , 0, sizeof(NetQueue_t));		}		memset(&m_conect.TransferQueue, 0, sizeof(NetQueue_t));		   	 /*   if(m_conect.NodeFree.pMallocAddress 	        && m_conect.NodeFree.buf_size > 0)	    {	        free(m_conect.NodeFree.pMallocAddress);	        m_conect.NodeFree.pMallocAddress = NULL;	   } 	    memset(&m_conect.NodeFree, 0, sizeof(Node_t));	  */	  /*  if(1 == m_conect.iClientFlag )	    {	        for(iChn = 0; iChn <ICaptureManager::instance()->GetLogicChnNum()+1;iChn ++)	        {	            if(INVALID_SOCKET != m_conect.MultiSock[iChn])	            {	                (void) shutdown( m_conect.MultiSock[iChn], 2);	                //(void) c(m_conect.MultiSock[iChn]);	                m_conect.MultiSock[iChn] = INVALID_SOCKET;	            }	        }	    }*/	    	    if (m_conect.hMutex)	    {	        MutexLeave(m_conect.hMutex);	    }   	    m_conect.sock = INVALID_SOCKET;		_printd("free disconnect!!!");	}	bool CNetWorkClient::ConnectRemoteServer()	{		unsigned short nPort = 0;		LPSERVENT lpServEnt;		SOCKADDR_IN sockAddr;		SOCKADDR_IN sockLocalAddr;		fd_set fdr, fdw;	    struct timeval timeout;		int res = 0;		bool conected = false;	    int    sock = INVALID_SOCKET;		LPHOSTENT testhost;		testhost = gethostbyname("www.baidu.com");		if(!testhost)		{			printf("Network is unreachable !!!\n");			//return false;		}	///	gethostbyname("www.baidu.com");		if((sock = socket(PF_INET, SOCK_STREAM,0)) == INVALID_SOCKET)		{			return false;		}		memset(&sockAddr,'\0',sizeof(SOCKADDR_IN));		sockAddr.sin_family = AF_INET;		sockAddr.sin_port = htons(inputpara.remoteport);		if((sockAddr.sin_addr.s_addr = inet_addr(inputpara.remotehost)) == INADDR_NONE)		{			LPHOSTENT host;				host = gethostbyname(inputpara.remotehost);			if (host)				memcpy(&sockAddr.sin_addr,host->h_addr_list[0],host->h_length);			else			{				close(sock);				return false;			}						}	//	gethostbyname("www.baidu.com");		printf("connect start2......sin_port=%x,sin_addr=%x!!!!!\n",sockAddr.sin_port,sockAddr.sin_addr.s_addr);		// start non-blocking mode for socket:		/*if(ioctl(m_iSock,FIONBIO, (unsigned long*)&ul) == SOCKET_ERROR)		{			close(m_iSock);			return false;		}*/		sockLocalAddr.sin_family = AF_INET;		sockLocalAddr.sin_port = 0;	//	bind(m_iSock,(struct sockaddr *)&sockLocalAddr,sizeof(sockLocalAddr));//绑定ip地址	//	listen(m_iSock, 3);#ifdef LINUX					int keepAlive = 1; // 开启keepalive属性		int keepIdle = 60; // 如该连接在60秒内没有任何数据往来,则进行探测		int keepInterval = 5; // 探测时发包的时间间隔为5 秒		int keepCount = 3; // 探测尝试的次数.如果第1次探测包就收到响应了,则后2次的不再发.		if( setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *)&keepAlive, sizeof(keepAlive)) < 0)		{			printf("setsockopt keepalive failed..\n");		}	 		else if(  setsockopt(sock, SOL_TCP, TCP_KEEPIDLE, (void*)&keepIdle, sizeof(keepIdle)) < 0 )		{			printf("setsockopt keepidle failed..\n");		}		else if( setsockopt(sock, SOL_TCP, TCP_KEEPINTVL, (void *)&keepInterval, sizeof(keepInterval)) < 0 )		{			printf("setsockopt keepintvl failed..\n");		}		else if( setsockopt(sock, SOL_TCP, TCP_KEEPCNT, (void *)&keepCount, sizeof(keepCount)) < 0 )		{			printf("setsockopt keepcnt failed..\n");		}						//gettimeofday(&current_time, NULL);#else				//current_time.tv_sec = 0;				//current_time.tv_usec = SystemGetMSCount()*1000; #endif		int    flags = fcntl(sock, F_GETFL, 0);		if (flags != -1)		{			fcntl(sock, F_SETFL, flags | O_NONBLOCK) ;		}		printf("connect start3.....!!!!!\n");		if( connect(sock,(LPSOCKADDR)&sockAddr,sizeof(sockAddr)) == SOCKET_ERROR )		{			if(errno != EINPROGRESS)			{				close(sock);				return false;			}			perror("Network connect fail...\n");		}#if defined(WIN32)					unsigned long	 ulON = 1;					ioctlsocket(sock, FIONBIO, &ulON);#else					/*int    flags = fcntl(m_iSock, F_GETFL, 0);					if (flags != -1)					{						fcntl(m_iSock, F_SETFL, flags | O_NONBLOCK) ;					}*/					int nSendBuf = 128*1024;//设置为128K					setsockopt(sock,SOL_SOCKET,SO_SNDBUF,(const char*)&nSendBuf,sizeof(int));			#endif /* _WIN32 */		FD_ZERO(&fdr);		FD_ZERO(&fdw);		FD_SET(sock, &fdr);		FD_SET(sock, &fdw);		timeout.tv_sec = 10;		timeout.tv_usec = 0;				res = select(sock + 1, &fdr, &fdw, NULL, &timeout);		if(res < 0) {			printf("Network test...\n");			perror("Network test...\n");			close(sock);			return false;		}				if(res == 0) {			printf("Connect server timeout");			close(sock);			return false;		}		 if(res == 2) {	       	 printf("Connect server timeout\n");			close(sock);	       	return false;	    }		m_conect.sock = sock;		char Uuid[32] 	= {0};		int iRet =0;// UuidReadConf(Uuid);		if(0 != iRet)		{			return false;		}		DVRIP szHead;		memset(&szHead, 0 , sizeof(DVRIP));		memcpy(szHead.head_token,"WJAPRIVA",8);		szHead.dvrip_cmd = DEV_REGISTER;		memcpy(&szHead.dvrip_p[0],inputpara.uuid,12);		szHead.dvrip_p[15]=1;		msghdr_t msghdr;		memset(&msghdr, 0, sizeof(msghdr));		msghdr.buf	   = (void*)&szHead;		msghdr.buf_len = sizeof(DVRIP);		//printf("connect start4......%p ----  %p!!!!!\n",NETWORKSERVICE::DvrNetSendMsg,DvrNetSendMsg);			DvrNetSendMsg(&m_conect, &msghdr);			printf("send DEV_REGISTER......end!!!!!\n");		sleep(2);		return true;	}	int CNetWorkClient::Run(Wja_InitNetworkParam para)	{	    printf("CNetWorkClient Run=======>>>>>>>>>>>>>>>>>\n");	    assert(m_bIsNetRunning == false);		memcpy(&inputpara,&para,sizeof(Wja_InitNetworkParam));		m_upgrate = new CClientUpgrate(inputpara.dir,inputpara.filename);	    m_bExitNetThread = false;	    	    if(CreateThread() == FALSE)	    {	        assert(0);	        return FAILURE_RET;	    }	    return SUCCESS_RET;	}	void CNetWorkClient::svc()	{  		printf("CNetWorkClient svc start=======>>>>>>>>>>>>>>>>>\n");	    while (!m_bExitNetThread)	    {	//		while(!ConnectRemoteServer("172.16.2.98", 5555))	//		while(!ConnectRemoteServer("c14878p105.51mypc.cn", 5555))				//		while(!ConnectRemoteServer("192.168.100.99", 5555))			while(!ConnectRemoteServer())	//		while(!ConnectRemoteServer("202.105.96.62",5556))			{				printf("Failed to connect to the server!!! \n");				printf("IO_DATALEN(m_remote)  = [%d] \n",IO_DATALEN(&m_remote));				for(int i = 0; i < 6; i++)//3分钟重连一次				{						sleep(2);				}			}			printf("CNetWorkClient svc loop=======>>>>>>>>>>>>>>>>>\n");			m_bIsNetRunning = true;			while(m_bIsNetRunning)			{				printf("connect to server successfull!\n");				NetClientPoll(5000);			}	    }	}	void CNetWorkClient::ThreadProc()	{	    CNetWorkClient *pClientDlgProc = (CNetWorkClient *)this;	    assert(pClientDlgProc);		printf("CNetWorkClient ThreadProc=======>>>>>>>>>>>>>>>>>\n");	    pClientDlgProc->svc();    	    return ;	}	int CNetWorkClient::Stop()	{	    printf("CNetWorkClient Stop=======>>>>>>>>>>>>>>>>>\n");	    if( m_bExitNetThread == false) 	    {   	    	m_bExitNetThread = TRUE;	        DestroyThread();	        m_bIsNetRunning = false;	    }	    return SUCCESS_RET;	}	void CNetWorkClient::NetClientFree(void* buf)	{		free((char*)buf);	}	int CNetWorkClient::NetClientRecv()	{		if(-1 == m_conect.sock)	    {	        return 0;	    }	    	    int n = 0;	    if (m_conect.flags & FLAG_SOCK_READABLE) //可读	    {	        const unsigned long len = IO_SPACELEN(&m_remote);	        n = recv(m_conect.sock, m_remote.buf + m_remote.head, len, 0);	        if (n == 0 || (n < 0 && ERRNO != EWOULDBLOCK))	        {	            perror("readremote");	            m_remote.done = 1;	            printf("$$$$$$$$$$$ socket is %d, ret: %d\n",m_conect.sock, n);	        }	        printf("NetClientRecv n =%d,len=%d\n",n,len);	        if (n > 0)	        {	            m_remote.head += n;	            m_remote.buf[m_remote.head] = '\0';	        } 	        else if (m_remote.done) 	        {	            m_conect.flags |= FLAG_FINISHED;	            m_conect.flags &= ~FLAG_IO_READY;	        }	    }    	    return n;		}	int CNetWorkClient::NetClientPoll(int milliseconds)	{	    struct timeval    tv;            /* Timeout for select() */	    fd_set        read_set, write_set;	    int        max_fd = 0, msec = milliseconds;		    const NetQueue_t *queue;	    	    FD_ZERO(&read_set);	    FD_ZERO(&write_set);	    int error=-1, len;		len = sizeof(error);		int     ret = getsockopt(m_conect.sock, SOL_SOCKET, SO_ERROR, (char*)&error, (socklen_t *)&len);		if( (ret != 0) || (error == EPIPE) )		{			printf("NetCorePoll():ret= %d error = %d\r\n",ret,error);		    CloseSocket();			return 0;		}		m_conect.flags &= ~FLAG_IO_READY;				queue = &m_conect.DataTransferQueue[0];		#define    MERGEFD(fd,set)    \	    do {FD_SET(fd, set); if (fd > max_fd) max_fd = fd; } while (0)		/* If there is space to read, do it */		if (IO_SPACELEN(&m_remote))			{MERGEFD(m_conect.sock, &read_set);}				/* If there is data in output queue, add to write set */		if (queue->head && (queue->totalSize > 0))			{MERGEFD(m_conect.sock, &write_set);}			    tv.tv_sec = msec / 1000;	    tv.tv_usec = msec % 1000;		// printf("NetClientPoll step1=======>>>>>>>>>>>>>>>>>\n");	    /* Check IO readiness */	    if (select(max_fd + 1, &read_set, &write_set, NULL, &tv) < 0) 	    {	        tracef("select: %s\r\n", strerror(errno));	        return 0;	    }	    /* Set IO readiness flags */		if (FD_ISSET(m_conect.sock, &read_set)) 		{			m_conect.flags |= FLAG_SOCK_READABLE;		}		if (FD_ISSET(m_conect.sock, &write_set))		{			m_conect.flags |= FLAG_SOCK_WRITABLE;		}	    /* handle if IO ready */		if (m_conect.flags & FLAG_SOCK_READABLE)	    {			NetClientIoProcess();		}		 //printf("NetClientPoll step2=======>>>>>>>>>>>>>>>>>\n");		if (m_conect.flags & FLAG_SOCK_WRITABLE) 	    {	        MutexEnter(m_conect.hMutex);   	        NetSendClientDataUnlock(&m_conect);	        MutexLeave(m_conect.hMutex);	    }		// printf("NetClientPoll step3=======>>>>>>>>>>>>>>>>>\n");		if (m_conect.flags & FLAG_FINISHED || (m_iKeepStatus >= 5))		{			_printd("FLAG_FINISHED");			m_iKeepStatus = 0;			CloseSocket();			return false;		}		return 0;	    	}	int CNetWorkClient::TimerCheckBuf(int arg)	{		int len = IO_DATALEN(&m_remote);		if(len && (m_iRecvLen == len))		{			m_iRecvFlag++;			if(m_iRecvFlag >= 5)			{				m_iRecvFlag = 0;				memset(&m_remote, 0, sizeof(struct io));//清空数据			}		}		else		{			m_iRecvFlag = 0;			m_iRecvLen = len;			_printd("m_iRcvLen = [%d]",len);		}	}		int CNetWorkClient::TimerKeepLive(int arg)	{		if(m_bIsNetRunning)		{			DVRIP szHead;			memset(&szHead, 0 , sizeof(DVRIP));			memcpy(szHead.head_token,"WJAPRIVA",8);			szHead.dvrip_cmd = KEEP_ALIVE;			msghdr_t msghdr;			memset(&msghdr, 0, sizeof(msghdr));			msghdr.buf     = (void*)&szHead;			msghdr.buf_len = sizeof(DVRIP);			DvrNetSendMsg(&m_conect, &msghdr);			m_iKeepStatus++;#if 0			if(m_iKeepStatus >= 5)//15分钟线程不处理任何消息则重开线程			{				//Stop(0, NULL);				CloseSocket();				_printd("Close Client Thread!!!");				sleep(5);				//Run(0, NULL);				//HisiSetFGSoftRestart(0);				sleep(5);			}#endif		}		m_iOnline++;		if(m_iOnline && (0 == (m_iOnline%2))) //1分钟检测一次网络		{			if(m_iOnline > 12)			// network is abnormal for 6min			{				//g_Log.Append(LOG_NET_ABORT); //网络断开									//cmdpopen((char*)"reboot");				printf("net is not reeached,banormal\n");			}			LPHOSTENT testhost;						testhost = gethostbyname("www.baidu.com");			if(testhost)			{				m_iOnline = 0;			}			else			{								//HisiSetFGSoftRestart(0);			}		}		_printd("TimerKeepLive!!!  m_bIsNetRunning[%d]",m_bIsNetRunning);	}	void CNetWorkClient::CloseSocket()	{		wja_RealTimePlayCloseAll();		wja_PlayBackSendStopAll();		wja_RecordSendStopAll();		m_bIsNetRunning = false;		m_bRegisterFlag = false;		m_iOnline = 0;		m_iKeepStatus = 0;		sleep(5);//等待其他线程			(void) shutdown(m_conect.sock, 2);		NetClientFreeBuf();		m_conect.flags = 0;		memset(&m_remote, 0, sizeof(struct io));		//HisiSetFGSoftRestart(0);		sleep(2);		_printd("\n m_remote.done = [%d]>>>m_remote.head[%d] m_remote.tail[%d]\n",m_remote.done, m_remote.head, m_remote.tail);	}	void CNetWorkClient::NetClientIoProcess()	{		_printd("NetClientIoProcess start!!!\n");	    assert(m_conect.sock != -1); 		int iRet = 0;	    unsigned long len = 0;	    NetClientRecv();				if(m_remote.head > m_remote.tail)		{	    	len = IO_DATALEN(&m_remote);		}		#if 0		while(len >= sizeof(DVRIP)) 		{			struct dvrip szHead;			memset(&szHead, 0 , sizeof(struct dvrip));			memcpy(&szHead,(char *)(m_remote.buf + m_remote.tail),sizeof(struct dvrip));			if (len >= (szHead.dvrip_extlen + sizeof(DVRIP))) 			{				_printd("====MsgProcess((char *)m_remote.head[%d] - m_remote.tail[%d], len=%d,szHead.dvrip_extlen + sizeof(DVRIP)=%d===== drip.cmd = %d\n",  m_remote.head, m_remote.tail,len,szHead.dvrip_extlen + sizeof(DVRIP),szHead.dvrip_cmd);				    iRet = MsgProcess((char *)m_remote.buf + m_remote.tail, szHead.dvrip_extlen + sizeof(DVRIP));				_printd("====MsgProcess iRet[%d]",iRet);					if((-1 == iRet) || (m_remote.tail >= m_remote.head))//防止死循环				{					len = 0;					break;				}								m_remote.tail += szHead.dvrip_extlen + sizeof(DVRIP);			  	len = IO_DATALEN(&m_remote);			} 			else 			{			    break;			}		}		#else		while(len >= sizeof(DVRIP)) 		{			struct dvrip szHead;			memset(&szHead, 0 , sizeof(struct dvrip));			memcpy(&szHead,(char *)(m_remote.buf + m_remote.tail),sizeof(struct dvrip));			if(memcmp(szHead.head_token,"WJAPRIVA",8)==0)			{				if (len >= (szHead.dvrip_extlen + sizeof(DVRIP))) 				{					_printd("====MsgProcess((char *)m_remote.head[%d] - m_remote.tail[%d], len=%d,szHead.dvrip_extlen + sizeof(DVRIP)=%d===== drip.cmd = %d\n",  m_remote.head, m_remote.tail,len,szHead.dvrip_extlen + sizeof(DVRIP),szHead.dvrip_cmd);					    iRet = MsgProcess((char *)m_remote.buf + m_remote.tail, szHead.dvrip_extlen + sizeof(DVRIP));					_printd("====MsgProcess iRet[%d]",iRet);						if((-1 == iRet) || (m_remote.tail >= m_remote.head))//防止死循环					{						len = 0;						break;					}										m_remote.tail += szHead.dvrip_extlen + sizeof(DVRIP);				  	len = IO_DATALEN(&m_remote);				} 				else 				{				    break;				}			}			else			{				m_remote.tail += sizeof(szHead.head_token);				printf("NetClientIoProcess data parse error,skip the continue to search head\n");				len = IO_DATALEN(&m_remote);			}		}		#endif		printf("MsgProcess len=%d,m_remote.head=%d,m_remote.tail =%d\n",len,m_remote.head,m_remote.tail);	    if ( len > 0 )	    {	        memcpy(m_remote.buf, m_remote.buf + m_remote.tail, len);	        m_remote.head = len; 	        m_remote.tail = 0;	    }		else		{			m_remote.head = 0;			m_remote.tail = 0;		}		_printd("NetClientIoProcess end!!!\n");	}	int CNetWorkClient::MsgProcess(char* buf, int len)	{		int iSendFlag = 0;		int itotalen = 0;		DVRIP szHead;		memset(&szHead, 0 , sizeof(DVRIP));		memcpy(&szHead,buf,sizeof(DVRIP));				if((false == m_bRegisterFlag && DEV_REGISTER != szHead.dvrip_cmd) || 0 == szHead.dvrip_cmd)		{			_printd("false == m_bRegisterFlag && DEV_REGISTER != szHead.dvrip_cmd");			//CloseSocket();			//m_conect.flags = FLAG_FINISHED;			return 0;		}		else if(false == m_bRegisterFlag && DEV_REGISTER == szHead.dvrip_cmd)		{			_printd("szHead.dvrip_r0[%d]",szHead.dvrip_r0);			if(szHead.dvrip_r0)			{				m_bRegisterFlag = true;				//重启浪涛服务SDK					//g_GooLink.Start();				_printd("Register successfull!\n");								CIVnPdu * rpReq = new CIVnPdu();				if(NULL == rpReq)				{					return 0;				}				CIVnPdu * rpResp = 0;				GetDevStatus(&szHead, rpResp);				if (rpResp)			    {			    	_printd("after Register successfull, send DevStatus !\n");			        msghdr_t msg_hdr;			        memset(&msg_hdr, 0, sizeof(msg_hdr));			        msg_hdr.buf     = (void*)rpResp->GetPacket();			        msg_hdr.buf_len = rpResp->GetPacketLen();			        DvrNetSendMsg(&m_conect, &msg_hdr);			        delete rpResp;			        rpResp = NULL;			    }				if(rpReq)				{					delete rpReq;				}				return 0;			}			else			{				//CloseSocket();				m_conect.flags = FLAG_FINISHED;				return -1;			}		}		CIVnPdu * pReq = new CIVnPdu();		CIVnPdu * pResp = NULL;		int iRet = 0;	    if (pReq && pReq->parseBody(buf, len))	    {        	        _printd("@@@@CNetWorkClient::MsgProcess@@@  cmd:<%d>\n", pReq->m_pIpHdr->dvrip_cmd);    			switch(pReq->m_pIpHdr->dvrip_cmd)			{			case QUERY_DEV_STATUS:			{					GetDevStatus(pReq->m_pIpHdr, pResp);			}				break;			case QUERY_DEV_WIFI:			{				printf("QUERY_DEV_WIFI-----\n");				GetWifiInfo(pReq, pResp);			}			break;			case MOD_DEV_WIFI:			{				printf("MOD_DEV_WIFI-----\n");				SetWifiInfo(pReq, pResp);			}			break;			case QUERY_DEV_LOG:			{				LogInfoSearch(pReq, pResp);			}			break;			case QUERY_DEV_SNAP:			{				_printd("QUERY_DEV_SNAP-----\n");				SnapStart(pReq, pResp);			}			break;			case UPDATA_VESION:			{				int filelen = 0;				int iRet = 0;				//memcpy(&filelen, &szHead.dvrip_p[0], 4);				filelen=szHead.dvrip_p[0]+(int)(szHead.dvrip_p[1] <<8) + (int)(szHead.dvrip_p[2] <<16) +(int) (szHead.dvrip_p[3] <<24);				_printd("filelen = [%d],dvrip_p[0-3]=%x-%x-%x-%x", filelen,szHead.dvrip_p[0],szHead.dvrip_p[1],szHead.dvrip_p[2],szHead.dvrip_p[3]);				m_upgrate->SetConnect(&m_conect);				iRet = m_upgrate->Start(filelen);					if(!iRet)				{					_printd("m_upgrate->Start error");					m_upgrate->SendUpgrateStatus(0);				}			}			break;			case UPDATA_NOW:			{				if(m_upgrate->UpgrateStatus())				{					_printd("UPDATA_NOW to AppendData\n");					m_upgrate->AppendData(buf + sizeof(DVRIP), szHead.dvrip_extlen);				}			}			break;			case KEEP_ALIVE:			{				_printd("keeplive..start!.!!!\n");				m_iKeepStatus = 0;				if(pReq->m_pIpHdr->dvrip_r0)				{					//m_iOnline = 0;				}				/*if(5 != glnk_get_state_to_server())				{					m_iOnline++;					_printd("m_iOnline[%d]",m_iOnline);					if(m_iOnline >= 5)					{						//4G拨号						//HisiSetFGSoftRestart(0);						sleep(2);						//重启浪涛服务SDK												_printd("g_GooLink.Start()---start!!!");						//g_GooLink.Start();						_printd("g_GooLink.Start()end");						m_iOnline = 0;						_printd("glnk_get_state_to_server!!! 1");					}								}				else				{					m_iOnline = 0;									_printd("glnk_get_state_to_server!!! 2 ");									}*/								_printd("keeplive!!! ");			}			break;			case RECORD_DOWNLOAD:			{				memcpy(&m_conect.iVodChn, &pReq->m_pIpHdr->dvrip_p[0],sizeof(int));				RecordDownLoadTime(pReq, pResp);				printf("RECORD_DOWNLOAD---pResp->GetPacketLen=%d--\n",pResp->GetPacketLen());			}			break;			case RESP_RCORD_DOWNLOAD:			{				printf("RESP_RCORD_DOWNLOAD-----\n");				RecordSendStart(pReq, pResp);			}			break;			case RESP_RCORD_STOP:			{				RecordSendStop(pReq, pResp);			}			break;			case QUERY_DEV_RECORD:			{				printf("QUERY_DEV_RECORD-----\n");				RecordFileSearch(pReq, pResp);			}			break;			case QUERY_RECORD_PLAYBACK:			{				RecordFileOpen(pReq, pResp);			}			break;			case RECORD_PLAYBACK_PRIVIEW:			{				RecordPlayBackStart(pReq, pResp);			}			break;			case CTRL_RECORD_PLAYBACK:			{				RecordPlayBackControl(pReq, pResp);			}			break;			case CTRL_VIDEO_PREVIEW:			{				RealTimeVideoPlayCtrl(pReq, pResp);			}			break;			default : 								break;			}	    }		else		{			_printd("pReq (%p)&& pReq->parseBody(buf(%p), len(%d)) return error",pReq,buf,len);		}	    if (pResp)	    {	        msghdr_t msghdr;	        memset(&msghdr, 0, sizeof(msghdr));	        msghdr.buf     = (void*)pResp->GetPacket();	        msghdr.buf_len = pResp->GetPacketLen();			_printd("pResp->m_pIpHdr->dvrip_cmd = %d\n",pResp->m_pIpHdr->dvrip_cmd);	        DvrNetSendMsg(&m_conect, &msghdr);	        delete pResp;	        pResp = NULL;	    }		if(NULL != pReq)		{			delete pReq;		}			return 0;	}	struct conn  CNetWorkClient::GetConnect()	{		return m_conect;	}	CNetWorkClient * CNetWorkClientFactory::instance()	{											static CNetWorkClient * _instance = NULL;				if( NULL == _instance)								{			_instance = new CNetWorkClient;			}													return _instance;							}		int CNetWorkClient::RecordDownLoadTime(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{		int iRet = 0;		unsigned int clientid=0;		char input[80];		WJA_RECORDTIME RecTime;		DVRIP head;		if( !pReqPDU )		{			return -1;		}		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));		clientid+=head.dvrip_p[20];		clientid <<=8;		clientid+=head.dvrip_p[21];		clientid <<=8;		clientid+=head.dvrip_p[22];		clientid <<=8;		clientid+=head.dvrip_p[23];		printf("RecordDownLoadTime  clientid ==%x,head.dvrip_p[20]=%x\n",clientid,head.dvrip_p[20]);		if(head.dvrip_r0)  //point start_time and end_time		{		memcpy(&RecTime ,pReqPDU->GetPacket()+ sizeof(DVRIP),sizeof(WJA_RECORDTIME));			iRet=wja_RecordDownLoadTimeSet(head.dvrip_p[0],RecTime,clientid);		}		else		{			memcpy(&input[0] ,pReqPDU->GetPacket()+ sizeof(DVRIP),80);			iRet=wja_RecordDownLoadFileOpen(head.dvrip_p[0],&input[0],clientid);		}		pRespPDU = new CIVnPdu();		if(!pRespPDU)		{		    return -1;		}			pRespPDU->packetBody((char *)NULL, 0);    		memcpy(pRespPDU->m_pIpHdr->head_token,"WJAPRIVA",8);		pRespPDU->m_pIpHdr->dvrip_cmd = RECORD_DOWNLOAD;		pRespPDU->m_pIpHdr->dvrip_r0= iRet;		pRespPDU->m_pIpHdr->dvrip_p[0]=head.dvrip_p[0];		pRespPDU->m_pIpHdr->dvrip_p[20]=head.dvrip_p[20];		pRespPDU->m_pIpHdr->dvrip_p[21]=head.dvrip_p[21];		pRespPDU->m_pIpHdr->dvrip_p[22]=head.dvrip_p[22];		pRespPDU->m_pIpHdr->dvrip_p[23]=head.dvrip_p[23];		return 0;			}	int CNetWorkClient::RecordSendStart(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{		if( !pReqPDU )		{			return -1;		}	    	int iRet = 0;		DVRIP head;		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));					iRet=wja_RecordSendStart(head.dvrip_p[0]);		//if(m_record)		{		//	iRet = m_record->startDiskReader(0);		}		/*if(!iRet)		{			pRespPDU = new CIVnPdu();			if(!pRespPDU)		    {		        return -1;		    }				pRespPDU->packetBody((char *)NULL, 0);   			pRespPDU->m_pIpHdr->dvrip_cmd = RESP_RCORD_DOWNLOAD;		}*/				return iRet;			}	int CNetWorkClient::RecordSendStop(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{			   	 int iRet = 0;		DVRIP head;		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));		iRet=wja_RecordSendStop(head.dvrip_p[0]);		//if(m_record)		{		//	iRet = m_record->stopDiskReader(0);		}		return iRet;	}	int CNetWorkClient::RecordFileSearch(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{				int iRet = 0,size=0;		WJA_NET_FILEINFO input;		WJA_NET_FILEINFO* output=NULL;				DVRIP head;		if( !pReqPDU )		{			printf("RecordFileSearch input pReqPDU is NULL\n");			return -1;		}		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));		memcpy(&input ,pReqPDU->GetPacket()+ sizeof(DVRIP),sizeof(WJA_NET_FILEINFO));		iRet=wja_VideoFileSearch_CallBack(&input,&output,&size);		pRespPDU = new CIVnPdu();		if(!pRespPDU)		{		    return -1;		}			pRespPDU->packetBody((char *)output, size*sizeof(WJA_NET_FILEINFO));    		memcpy(pRespPDU->m_pIpHdr->head_token,"WJAPRIVA",8);		pRespPDU->m_pIpHdr->dvrip_cmd = RESP_DEV_RCORD;		pRespPDU->m_pIpHdr->dvrip_r1  = 0;		pRespPDU->m_pIpHdr->dvrip_p[0]=head.dvrip_p[0];		if(output)			free(output);		return 0;			}	int CNetWorkClient::RecordFileOpen(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{				int iRet = 0;		char input[80];		WJA_RECORDTIME RecTime;		WJA_VideoDataFormat output;				DVRIP head;				if( !pReqPDU )		{			printf("RecordFileOpen input pReqPDU is NULL\n");			return -1;		}		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));		if(head.dvrip_r0)  //point start_time and end_time		{			memcpy(&RecTime ,pReqPDU->GetPacket()+ sizeof(DVRIP),sizeof(WJA_RECORDTIME));			iRet=wja_PlayBackPointTime(head.dvrip_p[0],RecTime,&output);		}		else		{		memcpy(&input ,pReqPDU->GetPacket()+ sizeof(DVRIP),sizeof(char)*80);			iRet=wja_PlayBackSendStreamOpen(head.dvrip_p[0],input,&output);		}				pRespPDU = new CIVnPdu();		if(!pRespPDU)		{		    return -1;		}			pRespPDU->packetBody((char *)&output, sizeof(WJA_VideoDataFormat)); 		memcpy(pRespPDU->m_pIpHdr->head_token,"WJAPRIVA",8);		pRespPDU->m_pIpHdr->dvrip_cmd = RESP_RECORD_PLAYBACK;		pRespPDU->m_pIpHdr->dvrip_r0  = iRet;		pRespPDU->m_pIpHdr->dvrip_p[0]=head.dvrip_p[0];		return 0;			}	int CNetWorkClient::RecordPlayBackStart(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{			   	 int iRet = 0;		DVRIP head;		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));		iRet=wja_PlayBackSendStart(head.dvrip_p[0]);		//if(m_record)		{		//	iRet = m_record->stopDiskReader(0);		}		return iRet;	}	int CNetWorkClient::RecordPlayBackControl(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{			   	 int iRet = 0;		DVRIP head;		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));		iRet=wja_PlayBackSendControl(head.dvrip_p[0],head.dvrip_p[1],head.dvrip_p[2]);		//if(m_record)		{		//	iRet = m_record->stopDiskReader(0);		}		return iRet;	}	int CNetWorkClient::RealTimeVideoPlayCtrl(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{			   	 int iRet = 0;		DVRIP head;		WJA_VideoDataFormat output;		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));		if((head.dvrip_p[1]==1)&&(head.dvrip_p[2] <2))		{			//打开vfware			iRet=wja_RealTimePlayOpen(head.dvrip_p[0],head.dvrip_p[2],&output);			pRespPDU = new CIVnPdu();			if(!pRespPDU)			{			    return -1;			}				pRespPDU->packetBody((char *)&output, sizeof(WJA_VideoDataFormat));    			memcpy(pRespPDU->m_pIpHdr->head_token,"WJAPRIVA",8);			pRespPDU->m_pIpHdr->dvrip_cmd = CTRL_VIDEO_PREVIEW;			pRespPDU->m_pIpHdr->dvrip_r1  = 0;			pRespPDU->m_pIpHdr->dvrip_p[0]=head.dvrip_p[0];			iRet =0;		}		else if((head.dvrip_p[1]==2)&&(head.dvrip_p[2] <2))				iRet=wja_RealTimePlayClose(head.dvrip_p[0],head.dvrip_p[2]);		else		{			printf("RealTimeVideoPlayCtrl head.dvrip_p[1]==%d,head.dvrip_p[2]=%derror\n",head.dvrip_p[1],head.dvrip_p[2]);			iRet=-1;		}		return iRet;	}	int CNetWorkClient::RealTimevideodataSend( unsigned char  channel,						unsigned char ismainorsub,			                    char isIFrame, 			                    void* Data, 			                    unsigned  DataLen,callback fun,void* arg)	{		#if 1		DVRIP* head=NULL;		msghdr_t msghdr[2];				if(!(head=(DVRIP*)malloc(sizeof(DVRIP))))		{			printf("RealTimevideodataSend malloc DVRIP error\n");			return -1;		}		memcpy(head->head_token,"WJAPRIVA",8);		head->dvrip_cmd = VIDEO_PREVIEW_DATA;		head->dvrip_r0=isIFrame;//帧类型		head->dvrip_extlen =DataLen;//帧大小					head->dvrip_p[0]=channel;//通道号		head->dvrip_p[1]=1;		head->dvrip_p[2]=ismainorsub;//码流类型		memset(&msghdr, 0, sizeof(msghdr));				msghdr[0].msgCmd   = 0;		msghdr[0].chn	   = channel;		msghdr[0].buf	   = head;		msghdr[0].buf_len  = sizeof(DVRIP);		msghdr[0].callback = NetClientFree;		msghdr[0].context  =head;		msghdr[0].msg_flags= MSG_FLAGS_MORE ;		msghdr[0].next	   = &msghdr[1];		if(fun !=NULL)		{			msghdr[1].msgCmd   = 0;			msghdr[1].chn	   = channel;	 			msghdr[1].buf	   = Data;			msghdr[1].buf_len  = DataLen;			msghdr[1].msg_flags= 0;			msghdr[1].callback = fun;			msghdr[1].context  = arg;			msghdr[1].iFrameFlag = PKT_FULL_FRAME;		}		else		{			char* videobuf=(char*)malloc(DataLen);			if(videobuf ==NULL)			{				printf("RealTimevideodataSend malloc videobuf(DataLen) error\n");				return -1;			}			memcpy(videobuf,(char*)Data,DataLen);			msghdr[1].msgCmd   = 0;			msghdr[1].chn	   = channel;	 			msghdr[1].buf	   = videobuf;			msghdr[1].buf_len  = DataLen;			msghdr[1].msg_flags= 0;			msghdr[1].callback = NetClientFree;			msghdr[1].context  =(void*)videobuf;			msghdr[1].iFrameFlag = PKT_FULL_FRAME;		}		#else		DVRIP head;		msghdr_t msghdr[2];						head.dvrip_cmd = VIDEO_PREVIEW_DATA;		head.dvrip_r0=isIFrame;		head.dvrip_extlen =DataLen;					head.dvrip_p[0]=channel;		head.dvrip_p[1]=1;		head.dvrip_p[2]=ismainorsub;		memset(&msghdr, 0, sizeof(msghdr));				msghdr[0].msgCmd   = 0;		msghdr[0].chn	   = channel;		msghdr[0].buf	   = &head;		msghdr[0].buf_len  = sizeof(DVRIP);		msghdr[0].callback = NULL;		msghdr[0].context  =NULL;		msghdr[0].msg_flags= MSG_FLAGS_MORE ;		msghdr[0].next	   = &msghdr[1];		msghdr[1].msgCmd   = 0;		msghdr[1].chn	   = channel;	 		msghdr[1].buf	   = Data;		msghdr[1].buf_len  = DataLen;		msghdr[1].msg_flags= 0;		msghdr[1].callback = fun;		msghdr[1].context  = arg;		msghdr[1].iFrameFlag = PKT_FULL_FRAME;				#endif		DvrNetSendChain(&m_conect, msghdr);		return 0;	}	int CNetWorkClient::RecordPlayBackSend(unsigned char channel, 							char isIFrame, 							void* Data, 						unsigned DataLen,callback fun,void* arg)	{		DVRIP* head=NULL;		msghdr_t msghdr[2];		if(!(head=(DVRIP*)malloc(sizeof(DVRIP))))		{			printf("RecordPlayBackSend malloc DVRIP error\n");			return -1;		}		memset(head,'\0',sizeof(DVRIP));		memcpy(head->head_token,"WJAPRIVA",8);		if(Data!=NULL)		{						head->dvrip_cmd = RECORD_PLAYBACK_PRIVIEW;			head->dvrip_r0=isIFrame;			head->dvrip_extlen =DataLen;							head->dvrip_p[0]=channel;			memset(&msghdr, 0, sizeof(msghdr));						msghdr[0].msgCmd   = 0;			msghdr[0].chn	   = channel;			msghdr[0].buf	   = head;			msghdr[0].buf_len  = sizeof(DVRIP);			msghdr[0].callback = NetClientFree;			msghdr[0].context  =head;			msghdr[0].msg_flags= MSG_FLAGS_MORE ;			msghdr[0].next	   = &msghdr[1];			if(fun !=NULL)			{				msghdr[1].msgCmd   = 0;				msghdr[1].chn	   = channel;	 				msghdr[1].buf	   = Data;				msghdr[1].buf_len  = DataLen;				msghdr[1].msg_flags= 0;				msghdr[1].callback = fun;				msghdr[1].context  = arg;				msghdr[1].iFrameFlag = PKT_FULL_FRAME;			}			else			{				char* videobuf=(char*)malloc(DataLen);				if(videobuf ==NULL)				{					printf("RecordPlayBackSend malloc videobuf(DataLen) error\n");					return -1;				}				memcpy(videobuf,(char*)Data,DataLen);				msghdr[1].msgCmd   = 0;				msghdr[1].chn	   = channel;	 				msghdr[1].buf	   = videobuf;				msghdr[1].buf_len  = DataLen;				msghdr[1].msg_flags= 0;				msghdr[1].callback = NetClientFree;				msghdr[1].context  =(void*)videobuf;				msghdr[1].iFrameFlag = PKT_FULL_FRAME;			}					}		else		{			head->dvrip_cmd = CTRL_RECORD_PLAYBACK;			head->dvrip_extlen =0;			head->dvrip_p[0]=channel;			head->dvrip_p[1]=2;			memset(&msghdr, 0, sizeof(msghdr));						msghdr[0].msgCmd   = 0;			msghdr[0].chn	   = channel;			msghdr[0].buf	   = head;			msghdr[0].buf_len  = sizeof(DVRIP);			msghdr[0].callback = NetClientFree;			msghdr[0].context  =head;			msghdr[0].msg_flags= 0 ;			msghdr[0].next	   = NULL;		}		DvrNetSendChain(&m_conect, msghdr);		return 0;	}	int CNetWorkClient::RecordDownLoadSend(unsigned char channel,                            							void* Data, 						unsigned DataLen,unsigned int clientid,callback fun,void* arg)	{		DVRIP* head=NULL;		msghdr_t msghdr[2];		if(!(head=(DVRIP*)malloc(sizeof(DVRIP))))		{			printf("RecordPlayBackSend malloc DVRIP error\n");			return -1;		}		memset(head,'\0',sizeof(DVRIP));		memcpy(head->head_token,"WJAPRIVA",8);		head->dvrip_p[0]=channel;		head->dvrip_p[20]=(clientid >>24)&0xFF;		head->dvrip_p[21]=(clientid >>16)&0xFF;		head->dvrip_p[22]=(clientid >>8)&0xFF;		head->dvrip_p[23]=clientid &0xFF;		if(Data!=NULL)		{						head->dvrip_cmd = RESP_RCORD_DOWNLOAD;			head->dvrip_extlen =DataLen;						memset(&msghdr, 0, sizeof(msghdr));						msghdr[0].msgCmd   = 0;			msghdr[0].chn	   = channel;			msghdr[0].buf	   = head;			msghdr[0].buf_len  = sizeof(DVRIP);			msghdr[0].callback = NetClientFree;			msghdr[0].context  =head;			msghdr[0].msg_flags= MSG_FLAGS_MORE ;			msghdr[0].next	   = &msghdr[1];						if(fun !=NULL)			{				msghdr[1].msgCmd   = 0;				msghdr[1].chn	   = channel;	 				msghdr[1].buf	   = Data;				msghdr[1].buf_len  = DataLen;				msghdr[1].msg_flags= 0;				msghdr[1].callback = fun;				msghdr[1].context  = arg;				msghdr[1].iFrameFlag = PKT_FULL_FRAME;			}			else			{				char* videobuf=(char*)malloc(DataLen);				if(videobuf ==NULL)				{					printf("RecordDownLoadSend malloc videobuf(DataLen) error\n");					return -1;				}				memcpy(videobuf,(char*)Data,DataLen);				msghdr[1].msgCmd   = 0;				msghdr[1].chn	   = channel;	 				msghdr[1].buf	   = videobuf;				msghdr[1].buf_len  = DataLen;				msghdr[1].msg_flags= 0;				msghdr[1].callback = NetClientFree;				msghdr[1].context  =(void*)videobuf;				msghdr[1].iFrameFlag = PKT_FULL_FRAME;			}						int iOldQueueSize = 0;			int iNewQueueSize = 0;			int iSendQueueSize = 0 ;			iOldQueueSize = m_conect.DataTransferQueue[0].totalSize + sizeof(DVRIP) +DataLen;			if(m_bIsNetRunning)			{				DvrNetSendChain(&m_conect, msghdr);			}			iNewQueueSize = m_conect.DataTransferQueue[0].totalSize;			iSendQueueSize = iOldQueueSize - iNewQueueSize;			if(iSendQueueSize > 60*1024)			{				SystemSleep(20);			}			else if(iSendQueueSize > 48*1024)			{				SystemSleep(15);			}			else if(iSendQueueSize > 36*1024)			{				SystemSleep(10);			}			else if(iSendQueueSize > 24*1024)			{				SystemSleep(5);			}			else if(iSendQueueSize > 12*1024)			{				SystemSleep(5);			}			static int iCnt = 0;			while(NetClientQueueOverLimit(&m_conect)) 			{				iOldQueueSize = m_conect.DataTransferQueue[0].totalSize;				iCnt++;				if(m_bIsNetRunning)				{					NetDvrSendQueue(&m_conect, channel, 0);								}				{					iNewQueueSize = m_conect.DataTransferQueue[0].totalSize;					iSendQueueSize = iOldQueueSize - iNewQueueSize;					if(iSendQueueSize > 60*1024)					{						SystemSleep(20);					}					else if(iSendQueueSize > 48*1024)					{						SystemSleep(15);					}					else if(iSendQueueSize > 36*1024)					{						SystemSleep(10);					}					else if(iSendQueueSize > 24*1024)					{						SystemSleep(5);					}					else if(iSendQueueSize > 12*1024)					{						SystemSleep(5);					}				}				// 如果当前状态已经停止，并且循环次数超过50,需要跳出此循环，防止死循环				// 目前的原因应该是在数据量大，在发送的过程中网络状况很糟糕或者网络断开可能会造成这种情况。				if (iCnt >= 100)				{					printf("RecordDownLoadSend iCnt >= 100\n");					iCnt = 0;					break;				}				SystemSleep(10);			}						iCnt = 0;		}		else		{			wja_RecordSendStop(channel);			head->dvrip_cmd = RESP_RCORD_STOP;			head->dvrip_extlen =0;			head->dvrip_p[0]=channel;			memset(&msghdr, 0, sizeof(msghdr));						msghdr[0].msgCmd   = 0;			msghdr[0].chn	   = channel;			msghdr[0].buf	   = head;			msghdr[0].buf_len  = sizeof(DVRIP);			msghdr[0].callback = NetClientFree;			msghdr[0].context  =head;			msghdr[0].msg_flags= 0 ;			msghdr[0].next	   = NULL;			DvrNetSendChain(&m_conect, msghdr);		}		return 0;	}int CNetWorkClient::SnapvideodataSend(unsigned char channel,                            							void* Data, 						unsigned DataLen,callback fun,void* arg)	{		DVRIP* head=NULL;		msghdr_t msghdr[2];				if(!(head=(DVRIP*)malloc(sizeof(DVRIP))))		{			printf("SnapvideodataSend malloc DVRIP error\n");			return -1;		}		memcpy(head->head_token,"WJAPRIVA",8);		head->dvrip_cmd = RESP_DEV_SNAP;		head->dvrip_r0=0;		head->dvrip_extlen =DataLen;					head->dvrip_p[0]=channel;		memset(&msghdr, 0, sizeof(msghdr));				msghdr[0].msgCmd   = 0;		msghdr[0].chn	   = channel;		msghdr[0].buf	   = head;		msghdr[0].buf_len  = sizeof(DVRIP);		msghdr[0].callback = NetClientFree;		msghdr[0].context  =head;		msghdr[0].msg_flags= MSG_FLAGS_MORE ;		msghdr[0].next	   = &msghdr[1];		if(fun !=NULL)		{			msghdr[1].msgCmd   = 0;			msghdr[1].chn	   = channel;	 			msghdr[1].buf	   = Data;			msghdr[1].buf_len  = DataLen;			msghdr[1].msg_flags= 0;			msghdr[1].callback = fun;			msghdr[1].context  = arg;			msghdr[1].iFrameFlag = PKT_FULL_FRAME;		}		else		{			char* videobuf=(char*)malloc(DataLen);			if(videobuf ==NULL)			{				printf("SnapvideodataSend malloc videobuf(DataLen) error\n");				return -1;			}			memcpy(videobuf,(char*)Data,DataLen);			msghdr[1].msgCmd   = 0;			msghdr[1].chn	   = channel;	 			msghdr[1].buf	   = videobuf;			msghdr[1].buf_len  = DataLen;			msghdr[1].msg_flags= 0;			msghdr[1].callback = NetClientFree;			msghdr[1].context  =(void*)videobuf;			msghdr[1].iFrameFlag = PKT_FULL_FRAME;		}		DvrNetSendChain(&m_conect, msghdr);		return 0;	}	int CNetWorkClient::GetDevStatus(const DVRIP* Req, CIVnPdu*& pRespPDU)	{				int iRet = 0;		WJA_DevStatus output;		if( !Req )		{			printf("CNetWorkClient::GetDevStatus Req is NULL\n");			return -1;		}		iRet=wja_GetDevStatus(Req->dvrip_p[0],&output);				pRespPDU = new CIVnPdu();		if(!pRespPDU)		{		    return -1;		}			pRespPDU->packetBody((char *)&output, sizeof(WJA_DevStatus)); 		memcpy(pRespPDU->m_pIpHdr->head_token,"WJAPRIVA",8);		pRespPDU->m_pIpHdr->dvrip_cmd = QUERY_DEV_STATUS;		pRespPDU->m_pIpHdr->dvrip_r0  = iRet;		pRespPDU->m_pIpHdr->dvrip_p[0]=Req->dvrip_p[0];		printf("GetDevStatus pRespPDU->m_pIpHdr->dvrip_extlen=%d\n",pRespPDU->m_pIpHdr->dvrip_extlen);		return 0;	}	int CNetWorkClient::GetWifiInfo(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{				int iRet = 0;		WJA_WifiInfo output;				DVRIP head;				iRet=wja_GetWifiInfo(&output);				pRespPDU = new CIVnPdu();		if(!pRespPDU)		{		    return -1;		}			pRespPDU->packetBody((char *)&output, sizeof(WJA_WifiInfo)); 		memcpy(pRespPDU->m_pIpHdr->head_token,"WJAPRIVA",8);		pRespPDU->m_pIpHdr->dvrip_cmd = QUERY_DEV_WIFI;		pRespPDU->m_pIpHdr->dvrip_r0  = iRet;		pRespPDU->m_pIpHdr->dvrip_p[0]=head.dvrip_p[0];		return 0;			}		int CNetWorkClient::SetWifiInfo(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{		int iRet = 0;		WJA_WifiInfo input;				DVRIP head;				if( !pReqPDU )		{			printf("RecordFileSearch input pReqPDU is NULL\n");			return -1;		}		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));		memcpy(&input ,pReqPDU->GetPacket()+ sizeof(DVRIP),sizeof(WJA_WifiInfo));		iRet=wja_SetWifiInfo(input);		return iRet;			}	int	CNetWorkClient::LogInfoSearch(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{				int iRet = 0,size=0;		WJA_NET_QUERY_SYSYTEM_LOG input;		WJA_NET_LOG_INFO* output=NULL;				DVRIP head;		if(!pReqPDU)		{			printf("RecordFileSearch input pReqPDU is NULL\n");			return -1;		}		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));		memcpy(&input ,pReqPDU->GetPacket()+ sizeof(DVRIP),sizeof(WJA_NET_QUERY_SYSYTEM_LOG));		//iRet=wja_VideoFileSearch_CallBack(&input,&output,&size);		iRet=wja_GetLogInfo_CallBack(&input,&output,&size);		_printd("wja_GetLogInfo_CallBack size =%d\n!!",size);		pRespPDU = new CIVnPdu();		if(!pRespPDU)		{		    return -1;		}		pRespPDU->packetBody((char *)output, size*sizeof(WJA_NET_LOG_INFO));    		memcpy(pRespPDU->m_pIpHdr->head_token,"WJAPRIVA",8);		pRespPDU->m_pIpHdr->dvrip_cmd = RESP_DEV_LOG;		pRespPDU->m_pIpHdr->dvrip_r1  = 0;		pRespPDU->m_pIpHdr->dvrip_p[0]=head.dvrip_p[0];		if(output)			free(output);		return 0;	}	int CNetWorkClient::SnapStart(CIVnPdu*& pReqPDU, CIVnPdu*& pRespPDU)	{		if( !pReqPDU )		{			return -1;		}	    	int iRet = 0;		DVRIP head;		memcpy(&head ,pReqPDU->GetPacket(),sizeof(DVRIP));					iRet=wja_SnapStart(head.dvrip_p[0]);				return iRet;	}}